<!DOCTYPE html>
<html lang="ja">
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
		<meta http-equiv="X-UA-Compatible" content="IE=edge">
		<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

		<title>パスワードチェッカー</title>

		<link rel="shortcut icon" href="../favicon.ico" type="image/vnd.microsoft.icon">
		<link rel="icon" href="https://vtmacs003b.github.io/favicon.ico" type="image/vnd.microsoft.icon">
		<link rel="apple-touch-icon-precomposed" href="../favicon-152.png">
		<meta name="msapplication-TileColor" content="#ffffff">
		<meta name="msapplication-TileImage" content="../favicon-144.png">

		<meta property="og:title" content="パスワードチェッカー">
		<meta property="og:type" content="website">
		<meta property="og:locale" content="ja_JP">
		<meta property="og:site_name" content="パスワードチェッカー">
		<meta property="og:url" content="https://vtmacs003b.github.io/password/">
		<meta property="og:image" content="https://vtmacs003b.github.io/password/password.png">
		<meta property="og:description" content="パスワードをチェックできるサイトです。">
		<link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0-alpha1/dist/css/bootstrap.min.css" rel="stylesheet" integrity="sha384-GLhlTQ8iRABdZLl6O3oVMWSktQOp6b7In1Zl3/Jr59b6EGGoI1aFkw7cmDA6j6gD" crossorigin="anonymous">
		<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap-icons@1.10.0/font/bootstrap-icons.css" integrity="sha384-l4UPAMHGzl7zwogLW4nOwaU2XTk6oiM1jhCRQstZEndoIiA2I5bg6fST3wzBSRBD" crossorigin="anonymous">

	</head>
	<body>
	<header>
	<nav class="navbar fixed-top navbar-expand-lg" style="background-color: #e3f2fd;">
		<div class="container-fluid">
			<a href="/maebashi.jp/" class="navbar-brand">
			<img src="../favicon.png" width="25" height="25" class="d-inline-block align-top" alt="M">
			パスワードチェッカー</a>
			<button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbar-header" aria-controls="navbarNav" aria-expanded="false" aria-label="Toggle navigation">
				<span class="navbar-toggler-icon"></span>
			</button>
			<div class="collapse navbar-collapse" id="navbar-header">
				<ul class="navbar-nav">
				<li class="nav-item"><a href="#words" class="nav-link"><i class="bi bi-key"></i>使える文字</a></li>
				<li class="nav-item"><a href="#time" class="nav-link"><i class="bi bi-stopwatch"></i>組み合わせと解読時間</a></li>
				<li class="nav-item"><a href="#check" class="nav-link"><i class="bi bi-shield-check"></i>パスワードチェック</a></li>
				<li class="nav-item"><a href="#calc" class="nav-link"><i class="bi bi-calculator"></i></i>計算回数について</a></li>
				</ul>
			</div>
		</div>
	</nav>
	</header>

	<article id="app">
	<div class="container">
		<div class="bg-light p-4 p-sm-5 my-4 rounded">
			<img src="password.png" class="img-fluid">
			<h1 class="display-4">パスワードチェッカー</h1>
			<p class="lead">
				パスワードについて、組み合わせと解読時間を調べたり、実際のパスワードの解読時間をチェックできる。<br>
				※１秒間の計算回数によって、解読時間は変化する。
			</p>
			<a class="btn btn-primary btn-lg" href="#words" role="button"><i class="bi bi-key"></i>使える文字</a>&nbsp;
			<a class="btn btn-primary btn-lg" href="#time" role="button"><i class="bi bi-stopwatch"></i>組み合わせと解読時間</a>&nbsp;
			<a class="btn btn-primary btn-lg" href="#check" role="button"><i class="bi bi-shield-check"></i>パスワードチェック</a>&nbsp;
			<a class="btn btn-primary btn-lg" href="#calc" role="button"><i class="bi bi-calculator"></i>計算回数について</a>&nbsp;
		</div>
	</div>

	<hr>

	<div id="words" class="container">
		<h2><i class="bi bi-key-fill"></i>パスワードで使える文字<i class="bi bi-key-fill"></i></h2>
		<div class="row">
			<div class="col-sm-12">
				パスワードで使える文字は以下の種類がある。
				<dl>
				<dt>数字</dt>
				<dd>0〜9 までの 10 個の数字。</dd>
				<dt>英小文字</dt>
				<dd>a〜z までの 26 個の文字。</dd>
				<dt>英大文字</dt>
				<dd>A〜Z までの 26 個の文字。</dd>
				<dt>記号</dt>
				<dd> ! " # $ % & ' ( ) - ^ \ @ [ ; : ] , . / _ = ~ | ` { + * } < > ? の 32 個の記号。<br>
				ただし、使える文字が制限されている場合がある。<br>
				また、\（バックスラッシュ）の代わりに ¥（円記号）か"使われることがある。</dd>
				</dl>
			</div>
		</div>
	</div><!-- #words -->

	<hr>

	<div id="time" class="container">
		<h2><i class="bi bi-stopwatch-fill"></i>組み合わせと解読時間<i class="bi bi-stopwatch-fill"></i></h2>
		<div class="row">
			<div class="col-sm-12">
				<dl>
				<dt>文字の種類</dt>
				<dd>
					パスワードで使う文字の種類をチェックする。<br>
					<input type="checkbox" id="num" value="num" checked v-model="checkedNames">
					<label for="num">数字</label>&nbsp;

					<input type="checkbox" id="low" value="low" v-model="checkedNames" />
					<label for="low">英小文字</label>&nbsp;

					<input type="checkbox" id="upp" value="upp" v-model="checkedNames" />
					<label for="upp">英大文字</label>&nbsp;

					<input type="checkbox" id="sym" value="sym" v-model="checkedNames" />
					<label for="sym">記号</label>
				</dd>
				<dt>組み合わせの数</dt>
				<dd>
					<span>下のスライダーを移動すると文字数を増減できる。</span><br>
					<label for="range" class="form-label">文字数：{{ range }}</label>
					<input id="range" type="range" class="form-range" value="1" min="1" max="36" step="1"  v-model="range">
					<p>
					上記の種類と文字数の組み合わせは<br>
					 {{ combi }} 通り。<br>
					つまり、<span class="fs-1 fw-semibold">{{ Jcombi }}</span> 通りになる。
					</p>
					<p>
					※ JavaScrpt の計算精度の問題により 22 桁以上は一定の誤差が生じる。
				 	</p>
				 </dd>
				<dt>解読時間</dt>
				<dd>
					<span>下のスライダーを移動すると解読時における１秒間の計算回数を増減できる。</span><br>
					<label for="timing" class="form-label">１秒間の計算回数：{{ times }} 回</label>
					<input id="timing" type="range" class="form-range" value="0" min="0" max="10" step="1"  v-model="timing">
					<p>
					上記の計算回数で解読するとその最大時間は<br>
					{{ analysis }} 秒。<br>
					つまり、<span class="fs-1 fw-semibold">{{ Janalysis }}</span>  になる。
					</p>
				 </dd>
				</dl>
			</div>
		</div>
	</div><!-- #time -->
	
	<hr>

	<div id="check" class="container">
		<h2><i class="bi bi-shield-fill-check"></i>パスワードチェッカー<i class="bi bi-shield-fill-check"></i></h2>
		<div class="row">
			<div class="col-sm-12">
				実際に使っているパスワードの強度を確認できる。
				<div class="form-floating">
					<input type="password" class="form-control" id="floatingPassword" placeholder="Password" v-model="password">
					<label for="floatingPassword">Password</label>
				</div>
				<ul>
					<li>{{ passLen }} 文字</li>
					<li v-if="numOn">数字が含まれている</li>
					<li v-if="lowOn">英小文字が含まれている</li>
					<li v-if="uppOn">英大文字が含まれている</li>
					<li v-if="symOn">記号が含まれている</li>
				</ul>
				<span>下のスライダーを移動すると解読時における１秒間の計算回数を増減できる。</span><br>
				<label for="timing2" class="form-label">１秒間の計算回数：{{ times2 }} 回</label>
				<input id="timing2" type="range" class="form-range" value="0" min="0" max="10" step="1"  v-model="timing2">
				<p>
				このパスワード「{{ password }}」は、１秒間に {{ times2 }} 回総当たりで解読すると
				<div v-html="passAnalysis"></div>
				通常は、総当たりではなく、辞書式の解読が用いられるため、実際はもっと速く解読できる。
				</p>
				<p>
				※ JavaScript 計算精度の問題により 22 文字以上は一定の誤差が生じる（おそらく、おおよその年は合っている）。
				</p>
			</div>
		</div>
	</div><!-- #check -->

	<hr>

	<div id="calc" class="container">
		<h2><i class="bi bi-calculator-fill"></i>計算回数について<i class="bi bi-calculator-fill"></i></h2>
		<div class="row">
			<div class="col-sm-12">
				１秒間の計算回数について、目安は以下の通り。<br>
				参考文献として
				<ol>
					<li><a href="https://logmi.jp/tech/articles/324500">12文字以下のパスワードは解読可能</a></li>
					<li><a href="https://www.marbacka.net/blog/wifi_password_safety_length/">Wi-Fiの暗号化キーは何文字あれば安全か</a></li>
					<li><a href="https://ja.wikipedia.org/wiki/FLOPS">FLOPS @ Wikipedia</a></li>
				</ol>
				として上げておく。参考文献 2 では、半精度（FP16）のFLOPS（1秒間の浮動小数点演算回数） を目安としている。しかし、参考文献 1 の実測値（ZIP方式のハッシュ解析）と参考文献 3 の単精度（FP32）のFLOPSを比較して、計算回数が1000桁ほどズレている。そのため、100億回のRTX2080Ti 以外は、単精度（FP32）のFLOPS を1000で割った値で算出している。これは、参考文献 1 における GTX 1600 SUPER と Tesla(NVIDIA) V100 の実測値と参考文献 3 の単精度のFLOPSから1000を割った値がほぼ同じになることから、参考値としても問題ないと判断した。ただし、少なくとも NVIDIA のアーキテクチャであれば問題ないが、Apple M1 Max ではさらに10分の1になったことから、NVIDIA 以外のアーキテクチャでは1桁程度の差が出る可能性がある（RTX2080Ti と M1 Max のFLOPS はほぼ同じ）。
				<dl>
				<dt>100万回</dt>
				<dd>
				</dd>
				<dt>1000万回</dt>
				<dd>
				</dd>
				<dt>1億回</dt>
				<dd>
				</dd>
				<dt>10億回</dt>
				<dd>
				Intel Iris Plus（GPU）でMD5（鍵長128bit）を演算した場合（<strong>実測：9.18億回</strong>）<br>
				Apple M1 Max 32コアの内蔵 GPUで ZipCrypto 方式の内部ハッシュ（鍵長96bit）を演算した場合（<strong>実測：10.408億回</strong>）<br>
				Intel Core i7-1065G7でMD5（鍵長128bit）を演算した場合（<strong>実測：13.225億回</strong>）<br>
				Apple Ultra 48コアの内蔵 GPUで ZipCrypto 方式の内部ハッシュ（鍵長96bit）を演算した場合（<strong>実測：15.787億回</strong>）<br>
				Sony Playstation 4 で ZipCrypto 方式の内部ハッシュ（鍵長96bit）を演算した場合（推定値：18億回）<br>
				</dd>
				<dt>100億回</dt>
				<dd>
				NVIDIA GeForce RTX 2080Ti １枚で ZipCrypto 方式の内部ハッシュ（鍵長96bit）を演算した場合（<strong>実測値：100億回</strong>）<br>
				Sony Playstation 5 で ZipCrypto 方式の内部ハッシュ（鍵長96bit）を演算した場合（推定値：103億回）<br>
				Xbox Series X で ZipCrypto 方式の内部ハッシュ（鍵長96bit）を演算した場合（推定値：121.5億回）<br>
				Apple M1 Max 32コアの内蔵 GPUでMD5（鍵長128bit）を演算した場合（<strong>実測：132.753億回</strong>）<br>
				Apple M1 Ultra 48コアの内蔵 GPUでMD5（鍵長128bit）を演算した場合（<strong>実測：171.389億回</strong>）<br>
				</dd>
				<dt>1000億回</dt>
				<dd>
				NVIDIA GeForce RTX 4090 １枚で ZipCrypto 方式の内部ハッシュ（鍵長96bit）を演算した場合（推定値：825.7536億回）<br>
				NVIDIA GeForce RTX 3090Ti ２枚で ZipCrypto 方式の内部ハッシュ（鍵長96bit）を演算した場合（推定値：799.9488億回）
				</dd>
				<dt>1兆回</dt>
				<dd>
				スーパーコンピュータ「京」で ZipCrypto 方式の内部ハッシュ（鍵長96bit）を演算した場合（推定値：１兆回）
				</dd>
				</dd>
				<dt>10兆回</dt>
				<dd>
				</dd>
				<dt>100兆回</dt>
				<dd>
				</dd>
				<dt>1000兆回</dt>
				<dd>
				スーパーコンピュータ「富岳」で ZipCrypto 方式の内部ハッシュ（鍵長96bit）を演算した場合（推定値：977兆回）
				</dd>
				<dt>1京回</dt>
				<dd>
				
				</dd>
				</dl>
				その他の参考文献
				<ul>
					<li><a href="https://www.cpu-monkey.com/ja/cpu_benchmark-igpu_fp32_single_precision_gflops-11">iGPU-FP32パフォーマンス（単精度GFLOPS）</a></li>
					<li><a href="http://arbitrage.jpn.org/it/gpu/">おすすめグラボのベンチマーク性能比較と選び方</a></li>
					<li><a href="https://devblog.lac.co.jp/entry/20220513"> ゲーミングPCのCPU、GPU性能をパスワードクラッキングでベンチマークしてみた</a></li>
					<li><a href="https://www.fujitsu.com/jp/about/businesspolicy/tech/k/whatis/system/">スーパーコンピュータ「京」はとてつもなく速い</a></li>
					<li><a href="https://www.fujitsu.com/jp/about/businesspolicy/tech/fugaku/specifications/">仕様 - スーパーコンピュータ「富岳」 : 富士通 - Fujitsu</a></li>
					<li>ハッシュ計算に利用したソフト<a href="https://hashcat.net/hashcat/">hashcat</a></li>
				</ul>
				<dl>
				<dt>ハッシュについて</dt>
				<dd>
				　通常、パスワードはそのまま保存されずに、ハッシュアルゴリズムを用いて別の文字列に変換される。ハッシュアルゴリズムによって作成された文字列は、そのままではパスワードとして使えないため、パスワードを知りたい場合はその文字列から解読を行う必要がある。<br>
				　ZipCrypto は Zip ファイルにパスワードをかけるときに使われるハッシュアルゴリズムである。現在は、比較的簡単に解読できてしまうため、非推奨となっている。<br>
				　MD5 はハッシュアルゴリズムの１つで、一番良く使われている。前身として、MD4 があり、Windows はこのハッシュアルゴリズムでパスワードを保存している（参考：<a href="https://learn.microsoft.com/ja-jp/windows-server/security/kerberos/passwords-technical-overview">パスワードの技術概要</a>）。MD4 の解読時間は MD5 と比較しておおよそ半分程度になる。<br>
				　Mac OS X は、パスワードの保存に、SHA512 というハッシュアルゴリズムを採用している。これは Windows のハッシュアルゴリズムと比較して、2万倍程度の強度がある。つまり、解読時間は MD5 と比較して1万倍になる。
				</dd>
				</dl>
			</div>
		</div>
	</div><!-- #calc -->

	</article>

	<footer class="bd-footer text-muted">
	<div class="container-fluid text-center">
		<hr>
		<p>
			Copyright © 2001- MACS-Project All Rights Reserved.
		</p>
	</div>
	</footer>

	<script src="https://unpkg.com/vue@3.2.36"></script>
	<script>
	Vue.createApp({
		data() {
			return {
				time : ["100万（1M）", "1000万（10M）", "1億（100M）", "10億（1G）", "100億（10G）", "1000億（100G）","1兆（1T）","10兆（10T）","100兆（100T）","1000兆（1P）","1京（10P）" ],
				time2 : ["1000000", "10000000", "100000000", "1000000000", "10000000000", "100000000000","1000000000000","10000000000000","100000000000000","1000000000000000","10000000000000000" ],
				checkedNames: ['num'],
				range: 1n,
				timing: 0n,
				timing2: 0n,
				password: "",
				numOn: false,
				lowOn: false,
				uppOn: false,
				symOn: false,
			}
		},
		computed: {
			combi() {
				let n = checked2num(this.checkedNames)
				return (n ** BigInt(this.range)).toLocaleString()
			},
			Jcombi() {
				let n = checked2num(this.checkedNames)
				return  ag2manshin(n ** BigInt(this.range)).toString()
			},
			times() {
				return this.time[Number(this.timing)]
			},
			times2() {
				return this.time[Number(this.timing2)]
			},
			analysis() {
				let n = checked2num(this.checkedNames)
				let aTime = (n ** BigInt(this.range)) / BigInt(this.time2[Number(this.timing)])
				return aTime
			},
			Janalysis() {
				let n = checked2num(this.checkedNames)
				let aTime = (n ** BigInt(this.range)) / BigInt(this.time2[Number(this.timing)])
				return makeTime(aTime)
			},
			passLen() {
				return this.password.length
			},
			passAnalysis() {
				let pass = this.password
				let n = 0n
				if(pass.match(/[0-9]/g)) {
					this.numOn = true
					n += 10n
				}  else {
					this.numOn = false
				}
				if(pass.match(/[a-z]/g)) {
					this.lowOn = true
					n += 26n
				} else {
					this.lowOn = false
				}
				if(pass.match(/[A-Z]/g)) { 
					this.uppOn = true
					n += 26n
				} else {
					this.uppOn = false
				}
				if(pass.match(/[!"#$%&'()\-^\\@[;:\],./_=~|`{+*}<>?¥]/g)) {
					this.symOn = true
					n += 32n
				} else {
					this.symOn = false
				}
				if(pass.match(/[^a-zA-Z\d!"#$%&'()\-^\\@[;:\],./_=~|`{+*}<>?¥]/g)) return "<span class=\"fs-2 fw-semibold\">パスワードに不適切な文字列が含まれているため、分析不可。</span>"

				let aTime = (n ** BigInt(this.password.length)) / BigInt(this.time2[Number(this.timing2)])
				return "最長 <span class=\"fs-1 fw-semibold\">" +  makeTime(aTime) + "</span> で解読可能。"
			}
		}
	}).mount('#app')

	// 文字の種類から場合の数を返す。
	function checked2num(c) {
		let n = 0n
		if(c.includes("num")) n+= 10n
		if(c.includes("low")) n+= 26n
		if(c.includes("upp")) n+= 26n
		if(c.includes("sym")) n+= 32n
		return n;
	}

	// 桁の大きな数値を万進の表記に変換して表示。https://memo.ag2works.tokyo/post-4722/
	function ag2manshin(a){
		//数値に変換できなかった場合
		if(isNaN(Number(a))) return console.log('Error : Not a Number.');
		//1万未満の場合
		if(Number(a) < 10000n) return a;

		//ゼロサプレスを行う関数
		let ag2zeroSuppress = n => {
			let i = 0;
			while (n.toString().charAt(i) === '0') i++;
			return n.toString().slice(i);
		}

		let hiNum, lowNum, pointNum, manshinUnit, manshinUnitLen;

		manshinUnit = ['万','億','兆','京','垓','𥝱','穣','溝','澗','正','載','極','恒河沙','阿僧祇','那由他','不可思議','無量大数'];
		manshinUnitLen = manshinUnit.length;

		//小数点を含めている場合
		if(a.toString().split('.').length > 1){
			pointNum = '.' + a.toString().split('.')[1];
			a = a.toString().split('.')[0];
		} else {
			pointNum = '';
		}

		hiNum = a;
		lowNum = '';

		for(let i = 0n, j = 0n, k = (a / 10000n); j < manshinUnitLen &&  k >= 1n; i++, j++, k /= 10000n){
			//下4桁をチェックして処理
			//4桁とも0の場合は万進の単位を削除
			if(i > 0n && !ag2zeroSuppress(hiNum.toString().slice(-4))) lowNum = lowNum.toString().slice(1);
			//1文字目に万進の単位、後ろに処理済みの下4桁を付けて保持
			lowNum = manshinUnit[i] + ag2zeroSuppress(hiNum.toString().slice(-4)) + lowNum;

			//下4桁を削除して保持
			hiNum = hiNum.toString().slice(0,-4);
		}

		//変換した表記の文字列を返す
		return hiNum + lowNum + pointNum;
	}
	function makeTime(num) {
		let y = num / (365n*24n*3600n);
		let d = num % (365n*24n*3600n) / (24n*3600n) | 0n;
		let h = num % (24n*3600n) / 3600n | 0n;
		let m =num % 3600n / 60n | 0n; 
		let s = num % 60n; 
		if(y > 10000) {
			return "約" + ag2manshin(y.toString()) + "年";
		} else if(y != 0) {
			return y + "年" + d + "日" + h + "時間" + m + "分" + s + "秒";
		} else if(d != 0)  {
			return d + "日" + h + "時間" + m + "分" + s + "秒";
		} else if(h != 0)  {
			return h + "時間" + m + "分" + s + "秒";
		} else if(m != 0)  {
			return m + "分" + s + "秒";
		} else if(s != 0)  {
			return s + "秒";
		} else {
			return "1 秒未満";
		}
	}
	</script>

	<script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','https://www.google-analytics.com/analytics.js','ga');

  ga('create', 'UA-90731510-1', 'auto');
  ga('send', 'pageview');

	</script>
	</body>
</html>
